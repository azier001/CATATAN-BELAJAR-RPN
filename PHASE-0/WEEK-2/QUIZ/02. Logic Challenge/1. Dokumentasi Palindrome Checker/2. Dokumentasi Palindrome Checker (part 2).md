# ğŸ“š Dokumentasi Lengkap: Palindrome Checker - Part 2

![Difficulty](https://img.shields.io/badge/Difficulty-Beginner-green) ![Topic](https://img.shields.io/badge/Topic-String%20Manipulation-blue) ![Language](https://img.shields.io/badge/Language-JavaScript-yellow)

> **Part 2: Solusi Alternatif 1 & 2 - Dari For Loop hingga String Reversal**

---

## ğŸ“‘ Navigasi Dokumentasi

- **[â† Kembali ke Part 1](https://github.com/azier001/CATATAN-BELAJAR-RPN/blob/main/PHASE-0/WEEK-2/QUIZ/02.%20Logic%20Challenge/1.%20Dokumentasi%20Palindrome%20Checker/1.%20Dokumentasi%20Palindrome%20Checker%20(part%201).md)** - Pengenalan & Debugging
- **Part 2 (Dokumen Ini)** - Solusi 1 & 2
- **[Lanjut ke Part 3 â†’](https://github.com/azier001/CATATAN-BELAJAR-RPN/blob/main/PHASE-0/WEEK-2/QUIZ/02.%20Logic%20Challenge/1.%20Dokumentasi%20Palindrome%20Checker/3.%20Dokumentasi%20Palindrome%20Checker%20(part%203).md)** - Solusi 3 & 4 + Best Practices

---

## ğŸ“‘ Daftar Isi Part 2

- [ğŸ’¡ Solusi Alternatif 1: For Loop - Versi Original](#solusi-1)
  - [ğŸ“ Ringkasan Algoritma](#solusi-1-algoritma)
  - [ğŸ’» Implementasi Code](#solusi-1-code)
  - [ğŸ” Cara Kerja](#solusi-1-cara-kerja)
  - [âš¡ Kompleksitas](#solusi-1-kompleksitas)
  - [âš–ï¸ Kelebihan & Kekurangan](#solusi-1-pros-cons)

- [ğŸ’¡ Solusi Alternatif 2: String Reversal Method](#solusi-2)
  - [ğŸ“ Ringkasan Algoritma](#solusi-2-algoritma)
  - [ğŸ’» Implementasi Code](#solusi-2-code)
  - [ğŸ” Cara Kerja](#solusi-2-cara-kerja)
  - [âš¡ Kompleksitas](#solusi-2-kompleksitas)
  - [âš–ï¸ Kelebihan & Kekurangan](#solusi-2-pros-cons)

---

<a name="solusi-1"></a>
## ğŸ’¡ Solusi Alternatif 1: For Loop - Versi Original

### ğŸ¯ Deskripsi Metode

Solusi ini menggunakan **for loop** untuk membandingkan karakter dari **depan dan belakang** secara bersamaan. Loop hanya berjalan sampai **setengah panjang string** karena kita membandingkan dua karakter sekaligus (dari depan dan belakang).

### ğŸ§© Konsep Utama:
- Loop dari index `0` hingga `Math.floor(kata.length / 2)`
- Bandingkan karakter ke-i dari depan dengan karakter ke-i dari belakang
- Jika ada yang tidak cocok, langsung return `false`
- Jika semua cocok, return `true`

### ğŸ“Š Ilustrasi:

Untuk kata `'katak'`:
```
Index:     0   1   2   3   4
Karakter: [k] [a] [t] [a] [k]
           â†“           â†‘
        Depan      Belakang

Loop 1: kata[0] vs kata[4] â†’ 'k' vs 'k' âœ…
Loop 2: kata[1] vs kata[3] â†’ 'a' vs 'a' âœ…
Loop 3: kata[2] tidak perlu dicek (tengah) â­ï¸
Result: true âœ…
```

---

<a name="solusi-1-algoritma"></a>
### ğŸ“ Ringkasan Algoritma (Versi Ujian)

**Algoritma For Loop - Versi Original:**

1. Loop dari index `0` sampai `Math.floor(kata.length / 2)`
2. Di setiap iterasi, bandingkan:
   - Karakter di index `i` (dari depan)
   - Karakter di index `kata.length - 1 - i` (dari belakang)
3. Jika ada karakter yang **tidak sama** (`!==`):
   - Return `false` (bukan palindrome)
4. Jika loop selesai tanpa menemukan perbedaan:
   - Return `true` (palindrome)

**Kompleksitas:**
- â±ï¸ Time: `O(n/2)` â†’ simplified to `O(n)`
- ğŸ’¾ Space: `O(1)` (hanya variable loop)

---

<a name="solusi-1-code"></a>
### ğŸ’» Implementasi Code

```javascript
function palindrome(kata) {
  // Loop hanya sampai setengah panjang string
  for (let i = 0; i < Math.floor(kata.length / 2); i++) {
    // Bandingkan karakter dari depan dengan dari belakang
    if (kata[i] !== kata[kata.length - 1 - i]) {
      return false  // Jika tidak sama, bukan palindrome
    } 
  }
  
  return true  // Jika semua sama, palindrome
}

// TEST CASES
console.log(palindrome('katak'));       // true âœ…
console.log(palindrome('blanket'));     // false âœ…
console.log(palindrome('civic'));       // true âœ…
console.log(palindrome('kasur rusak')); // true âœ…
console.log(palindrome('mister'));      // false âœ…
```

---

<a name="solusi-1-cara-kerja"></a>
### ğŸ” Cara Kerja Detail

Mari kita trace execution untuk beberapa contoh:

#### ğŸ“Œ Example 1: `palindrome('katak')`

```javascript
kata = 'katak'
kata.length = 5
Math.floor(5 / 2) = 2

Loop 1 (i = 0):
  kata[0] = 'k'
  kata[5 - 1 - 0] = kata[4] = 'k'
  'k' !== 'k' ? false â†’ Lanjut loop

Loop 2 (i = 1):
  kata[1] = 'a'
  kata[5 - 1 - 1] = kata[3] = 'a'
  'a' !== 'a' ? false â†’ Lanjut loop

Loop selesai â†’ return true âœ…
```

#### ğŸ“Œ Example 2: `palindrome('blanket')`

```javascript
kata = 'blanket'
kata.length = 7
Math.floor(7 / 2) = 3

Loop 1 (i = 0):
  kata[0] = 'b'
  kata[7 - 1 - 0] = kata[6] = 't'
  'b' !== 't' ? true â†’ return false âŒ

Function berhenti di loop pertama!
```

#### ğŸ“Œ Example 3: `palindrome('civic')`

```javascript
kata = 'civic'
kata.length = 5
Math.floor(5 / 2) = 2

Loop 1 (i = 0):
  kata[0] = 'c'
  kata[5 - 1 - 0] = kata[4] = 'c'
  'c' !== 'c' ? false â†’ Lanjut loop

Loop 2 (i = 1):
  kata[1] = 'i'
  kata[5 - 1 - 1] = kata[3] = 'i'
  'i' !== 'i' ? false â†’ Lanjut loop

Loop selesai â†’ return true âœ…
```

### ğŸ¯ Key Points:

1. **Efisiensi:** Hanya cek setengah string (tidak perlu cek karakter tengah)
2. **Early Exit:** Langsung return `false` saat menemukan ketidakcocokan
3. **Formula belakang:** `kata.length - 1 - i` selalu memberikan index dari belakang yang sesuai

---

<a name="solusi-1-kompleksitas"></a>
### âš¡ Kompleksitas

#### â±ï¸ Time Complexity: **O(n/2) â†’ O(n)**

**Penjelasan:**
- Loop berjalan `n/2` kali (setengah panjang string)
- Setiap iterasi melakukan 1 perbandingan: `O(1)`
- Total: `O(n/2)` yang disederhanakan menjadi `O(n)`

**Best Case:** `O(1)`
- Jika karakter pertama dan terakhir langsung berbeda
- Contoh: `'abc'` â†’ langsung return `false`

**Worst Case:** `O(n)`
- Jika harus cek semua karakter hingga tengah
- Contoh: `'katak'` â†’ cek semua hingga selesai

#### ğŸ’¾ Space Complexity: **O(1)**

**Penjelasan:**
- Hanya menggunakan 1 variable: `i` (loop counter)
- Tidak membuat array atau string baru
- Memory usage konstan, tidak bergantung ukuran input

---

<a name="solusi-1-pros-cons"></a>
### âš–ï¸ Kelebihan & Kekurangan

#### âœ… Kelebihan:

1. **Efisien dalam penggunaan memory** ğŸ’¾
   - Space complexity: O(1)
   - Tidak membuat copy string

2. **Fast untuk non-palindrome** âš¡
   - Early exit saat menemukan perbedaan
   - Tidak perlu cek semua karakter

3. **Mudah dipahami** ğŸ§ 
   - Logika straightforward
   - Cocok untuk pemula

#### âŒ Kekurangan:

1. **Kurang readable untuk pemula** ğŸ‘€
   - Formula `kata.length - 1 - i` butuh pemikiran ekstra
   - Tidak intuitif untuk yang baru belajar

2. **Tidak ada built-in method** ğŸ”§
   - Harus manual loop dan compare
   - Lebih banyak code dibanding solusi lain

3. **Kurang expressive** ğŸ“
   - Tidak langsung terlihat tujuannya
   - Butuh comment untuk clarity

---

## ğŸ¯ Kapan Menggunakan Solusi 1?

**Gunakan solusi ini jika:**
- âœ… Memory efficiency adalah prioritas utama
- âœ… Dealing dengan string yang sangat panjang
- âœ… Perlu performance terbaik untuk non-palindrome
- âœ… Interview coding yang fokus pada space complexity

**Hindari solusi ini jika:**
- âŒ Prioritas adalah code readability
- âŒ Team lebih prefer simple & clean code
- âŒ String input relatif pendek (< 1000 char)

---

<a name="solusi-2"></a>
## ğŸ’¡ Solusi Alternatif 2: String Reversal Method

### ğŸ¯ Deskripsi Metode

Solusi ini menggunakan **built-in JavaScript methods** untuk membalik string, kemudian membandingkan string asli dengan string yang sudah dibalik. Ini adalah **solusi paling sederhana dan paling mudah dipahami**.

### ğŸ§© Konsep Utama:
- Convert string menjadi array dengan `.split('')`
- Reverse array dengan `.reverse()`
- Convert kembali ke string dengan `.join('')`
- Bandingkan dengan string asli

### ğŸ“Š Ilustrasi:

Untuk kata `'katak'`:
```
Original:  'katak'
           â†“ .split('')
Array:     ['k', 'a', 't', 'a', 'k']
           â†“ .reverse()
Reversed:  ['k', 'a', 't', 'a', 'k']
           â†“ .join('')
Result:    'katak'

'katak' === 'katak' ? true âœ…
```

Untuk kata `'blanket'`:
```
Original:  'blanket'
           â†“ .split('')
Array:     ['b', 'l', 'a', 'n', 'k', 'e', 't']
           â†“ .reverse()
Reversed:  ['t', 'e', 'k', 'n', 'a', 'l', 'b']
           â†“ .join('')
Result:    'teknalb'

'blanket' === 'teknalb' ? false âŒ
```

---

<a name="solusi-2-algoritma"></a>
### ğŸ“ Ringkasan Algoritma (Versi Ujian)

**Algoritma String Reversal Method:**

1. Ubah string menjadi array dengan `.split('')`
2. Balik urutan array dengan `.reverse()`
3. Gabungkan kembali menjadi string dengan `.join('')`
4. Bandingkan string asli dengan string yang sudah dibalik menggunakan `===`
5. Return hasil perbandingan (`true` atau `false`)

**Kompleksitas:**
- â±ï¸ Time: `O(n)` (split + reverse + join + compare)
- ğŸ’¾ Space: `O(n)` (membuat array dan string baru)

---

<a name="solusi-2-code"></a>
### ğŸ’» Implementasi Code

```javascript
function palindrome(word) {
  // Balik string menggunakan split-reverse-join
  const reversedWord = word.split('').reverse().join('')
  
  // Bandingkan string asli dengan string terbalik
  return word === reversedWord
}

// TEST CASES
console.log(palindrome('katak'));       // true âœ…
console.log(palindrome('blanket'));     // false âœ…
console.log(palindrome('civic'));       // true âœ…
console.log(palindrome('kasur rusak')); // true âœ…
console.log(palindrome('mister'));      // false âœ…
```

### ğŸ¨ Variasi Code (Satu Baris):

```javascript
// One-liner version (tanpa variable intermediate)
function palindrome(word) {
  return word === word.split('').reverse().join('')
}
```

---

<a name="solusi-2-cara-kerja"></a>
### ğŸ” Cara Kerja Detail

Mari kita breakdown setiap step dengan detail:

#### ğŸ“Œ Step 1: `.split('')` - String ke Array

```javascript
word = 'katak'
word.split('') 
// Result: ['k', 'a', 't', 'a', 'k']

// Penjelasan:
// split('') memisahkan setiap karakter menjadi element array
// Parameter '' (empty string) artinya split setiap karakter
```

#### ğŸ“Œ Step 2: `.reverse()` - Balik Array

```javascript
['k', 'a', 't', 'a', 'k'].reverse()
// Result: ['k', 'a', 't', 'a', 'k']

// Penjelasan:
// reverse() membalik urutan element array
// Element pertama jadi terakhir, dst
// Note: reverse() mengubah array original (mutable)
```

#### ğŸ“Œ Step 3: `.join('')` - Array ke String

```javascript
['k', 'a', 't', 'a', 'k'].join('')
// Result: 'katak'

// Penjelasan:
// join('') menggabungkan semua element array menjadi string
// Parameter '' artinya tidak ada separator
```

#### ğŸ“Œ Step 4: Comparison - Bandingkan

```javascript
word === reversedWord
'katak' === 'katak'
// Result: true

// Penjelasan:
// Operator === membandingkan value dan type
// Return boolean (true/false)
```

### ğŸ¬ Full Execution Flow:

```javascript
palindrome('katak')

Step 1: word.split('')
  Input:  'katak'
  Output: ['k', 'a', 't', 'a', 'k']

Step 2: .reverse()
  Input:  ['k', 'a', 't', 'a', 'k']
  Output: ['k', 'a', 't', 'a', 'k']

Step 3: .join('')
  Input:  ['k', 'a', 't', 'a', 'k']
  Output: 'katak'

Step 4: word === reversedWord
  'katak' === 'katak'
  Output: true âœ…

Final Result: true
```

### ğŸ“Œ Contoh Non-Palindrome:

```javascript
palindrome('blanket')

Step 1: 'blanket'.split('')
  â†’ ['b', 'l', 'a', 'n', 'k', 'e', 't']

Step 2: .reverse()
  â†’ ['t', 'e', 'k', 'n', 'a', 'l', 'b']

Step 3: .join('')
  â†’ 'teknalb'

Step 4: 'blanket' === 'teknalb'
  â†’ false âŒ

Final Result: false
```

---

<a name="solusi-2-kompleksitas"></a>
### âš¡ Kompleksitas

#### â±ï¸ Time Complexity: **O(n)**

**Breakdown operasi:**

| Operasi | Complexity | Penjelasan |
|---------|-----------|------------|
| `.split('')` | O(n) | Iterasi setiap karakter |
| `.reverse()` | O(n) | Iterasi setengah array |
| `.join('')` | O(n) | Iterasi setiap element |
| `===` comparison | O(n) | Compare setiap karakter |
| **Total** | **O(n)** | Dominated by linear operations |

**Penjelasan:**
- Meskipun ada 4 operasi O(n), mereka sequential (tidak nested)
- Total tetap O(n), bukan O(4n) karena constant factor diabaikan
- Setiap operasi harus memproses semua n karakter

#### ğŸ’¾ Space Complexity: **O(n)**

**Memory yang digunakan:**

1. **Array dari split:** `O(n)` 
   - Membuat array berisi n elements
   
2. **Reversed array:** `O(1)` 
   - `.reverse()` modify in-place (tidak buat array baru)
   
3. **String dari join:** `O(n)` 
   - Membuat string baru dengan n karakter

**Total Space:** `O(n) + O(n) = O(2n) â†’ O(n)`

---

<a name="solusi-2-pros-cons"></a>
### âš–ï¸ Kelebihan & Kekurangan

#### âœ… Kelebihan:

1. **Extremely readable** ğŸ“–
   - Code sangat jelas dan self-explanatory
   - Bahkan non-programmer bisa paham konsepnya

2. **Concise & elegant** âœ¨
   - Bisa dibuat one-liner
   - Minimal code untuk maximum clarity

3. **Easy to maintain** ğŸ”§
   - Menggunakan built-in methods yang sudah tested
   - Tidak ada logic error yang mungkin terjadi

4. **Great for beginners** ğŸ“
   - Mudah dipahami konsepnya
   - Tidak perlu mikir tentang index calculation

5. **Interview friendly** ğŸ’¼
   - Menunjukkan pengetahuan JavaScript methods
   - Fast to implement

#### âŒ Kekurangan:

1. **Higher memory usage** ğŸ’¾
   - Space complexity O(n)
   - Membuat array dan string baru

2. **Slower untuk very long strings** ğŸŒ
   - Multiple operations: split, reverse, join
   - Overhead dari method calls

3. **Tidak efficient untuk large-scale** ğŸ“Š
   - Jika handle millions of strings
   - Memory bisa jadi bottleneck

4. **No early exit** â­ï¸
   - Harus proses semua karakter dulu
   - Tidak bisa stop early jika ketemu perbedaan

---

## ğŸ¯ Kapan Menggunakan Solusi 2?

**Gunakan solusi ini jika:**
- âœ… Code readability adalah prioritas
- âœ… String input relatif pendek
- âœ… Rapid prototyping atau quick implementation
- âœ… Teaching/learning context
- âœ… Code review oleh team yang prefer simple code

**Hindari solusi ini jika:**
- âŒ Dealing dengan very large strings (> 10,000 chars)
- âŒ Memory adalah constraint
- âŒ Performance critical application
- âŒ Processing millions of strings

---

## ğŸ“Š Perbandingan Solusi 1 vs Solusi 2

| Aspek | Solusi 1 (For Loop) | Solusi 2 (String Reversal) |
|-------|---------------------|---------------------------|
| **Readability** | ğŸŸ¡ Medium | ğŸŸ¢ Excellent |
| **Memory Usage** | ğŸŸ¢ O(1) | ğŸŸ¡ O(n) |
| **Speed (non-palindrome)** | ğŸŸ¢ Fast (early exit) | ğŸŸ¡ Must process all |
| **Code Length** | ğŸŸ¡ ~6 lines | ğŸŸ¢ ~2 lines |
| **Maintainability** | ğŸŸ¡ Medium | ğŸŸ¢ Easy |
| **Beginner Friendly** | ğŸŸ¡ Medium | ğŸŸ¢ Very friendly |
| **Interview** | ğŸŸ¢ Shows algo skill | ğŸŸ¢ Shows JS knowledge |
| **Large Scale** | ğŸŸ¢ Better | ğŸŸ¡ Acceptable |

### ğŸ† Rekomendasi:

- **Untuk Learning:** Solusi 2 (lebih mudah dipahami)
- **Untuk Production (small scale):** Solusi 2 (readability wins)
- **Untuk Production (large scale):** Solusi 1 (efficiency matters)
- **Untuk Interview:** **Tunjukkan KEDUA solusi** (menunjukkan fleksibilitas)

---

## ğŸ‰ Selesai - Part 2

Kamu sudah mempelajari:
- âœ… Solusi 1: For Loop approach dengan early exit
- âœ… Solusi 2: String Reversal dengan built-in methods
- âœ… Detail cara kerja masing-masing solusi
- âœ… Kompleksitas time & space
- âœ… Kelebihan & kekurangan setiap approach
- âœ… Kapan menggunakan solusi mana

### ğŸ“Œ Lanjut ke Part 3:

Di Part 3, kita akan explore **2 solusi lagi PLUS best practices**:

**Solusi yang akan dibahas:**
1. **Two Pointers** (menggunakan while loop)
2. **For Loop Refactored** (versi paling clean)

**Plus tambahan:**
- ğŸ¨ Best Practices & Clean Code Principles
- ğŸ“ Naming Convention (Indonesia vs English)
- ğŸ“Š Perbandingan lengkap 4 solusi
- ğŸ“ Key Takeaways
- ğŸ’ª Latihan tambahan
- ğŸ“š Referensi & resources

**Get ready untuk level up!** ğŸš€

---

> ğŸ’¡ **Pro Tip:** Coba implementasikan kedua solusi ini sendiri tanpa melihat code! Gunakan ringkasan algoritma sebagai guide. Ini akan meningkatkan pemahaman dan muscle memory kamu dalam coding!

---

*Dokumentasi dibuat untuk pembelajaran pribadi | Last updated: 2026*
